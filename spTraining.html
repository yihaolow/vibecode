<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CSV Attendance Report Generator</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              sans: ["Inter", "sans-serif"],
            },
          },
        },
      };
    </script>
    <style>
      body {
        background-color: #f7f9fb;
        font-family: "Inter", sans-serif;
      }
      .container-box {
        background-color: #ffffff;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1),
          0 2px 4px -2px rgba(0, 0, 0, 0.1);
      }
      .csv-output {
        white-space: pre; /* Essential for preserving CSV formatting in the textarea */
        overflow-x: auto;
        min-height: 200px;
      }
    </style>
  </head>
  <body class="p-4 sm:p-8">
    <div class="max-w-4xl mx-auto">
      <h1 class="text-3xl font-bold text-gray-800 mb-6 border-b pb-2">
        Chinese Chess Attendance Report Generator
      </h1>

      <!-- Input and Control Panel -->
      <div class="container-box p-6 rounded-lg mb-8">
        <h2 class="text-xl font-semibold mb-4 text-gray-700">
          1. Upload CSV File
        </h2>
        <div class="flex flex-col sm:flex-row gap-4 items-center">
          <input
            type="file"
            id="csvFile"
            accept=".csv"
            class="w-full sm:w-auto flex-grow text-gray-700 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100"
          />
          <button
            onclick="processCSV()"
            id="processButton"
            class="w-full sm:w-auto px-6 py-2 bg-indigo-600 text-white font-semibold rounded-full hover:bg-indigo-700 transition duration-150 shadow-md"
          >
            Process & Generate Report
          </button>
        </div>
        <p id="message" class="mt-4 text-sm text-gray-500 hidden">
          Please select a CSV file to begin processing.
        </p>
      </div>

      <!-- Output Panel -->
      <div class="container-box p-6 rounded-lg">
        <h2 class="text-xl font-semibold mb-4 text-gray-700">
          2. Generated CSV Output
        </h2>

        <!-- Output Text Area -->
        <textarea
          id="csvOutput"
          readonly
          placeholder="The processed attendance data will appear here..."
          class="csv-output w-full p-3 border border-gray-300 rounded-lg bg-gray-50 text-sm text-gray-800 focus:ring-indigo-500 focus:border-indigo-500"
        >
        </textarea>

        <!-- Download Button -->
        <div class="mt-4 flex justify-end">
          <button
            onclick="downloadCSV()"
            id="downloadButton"
            disabled
            class="px-6 py-2 bg-green-600 text-white font-semibold rounded-full hover:bg-green-700 transition duration-150 shadow-md disabled:opacity-50 disabled:cursor-not-allowed"
          >
            Download Output (.csv)
          </button>
        </div>
      </div>
    </div>

    <script>
      // --- Utility Functions for CSV and Date Handling ---

      // Simple CSV parser for standard comma-separated values, handling quotes
      function parseCSV(text) {
        const rows = text.trim().split("\n");
        if (rows.length === 0) return [];

        const data = [];
        for (let i = 1; i < rows.length; i++) {
          // Start from 1 to skip the header row
          const row = rows[i];
          if (row.trim() === "") continue;

          // Split by comma, respecting quotes
          const values = [];
          let inQuote = false;
          let current = "";

          for (let j = 0; j < row.length; j++) {
            const char = row[j];

            if (char === '"') {
              inQuote = !inQuote;
              // Handle double quotes inside a quoted field (escaped quote)
              if (j + 1 < row.length && row[j + 1] === '"' && inQuote) {
                current += '"';
                j++; // Skip the next quote since it's part of the content
              }
            } else if (char === "," && !inQuote) {
              values.push(current.trim());
              current = "";
            } else {
              current += char;
            }
          }
          values.push(current.trim()); // Push the last column

          // Clean up leading/trailing quotes from values
          const cleanedValues = values.map((v) =>
            v.replace(/^"|"$/g, "").trim()
          );
          data.push(cleanedValues);
        }
        return data;
      }

      // Converts DD/MM/YYYY to MM-DD for display and YYYY-MM-DD for sorting
      function formatDate(dateStr) {
        const parts = dateStr.split("/");
        // Ensure dateStr is valid (e.g., has 3 parts)
        if (parts.length < 3) {
          return { sortKey: "9999-99-99", headerDisplay: "Invalid Date" };
        }

        const [day, month, year] = parts;
        // Note: Date constructor uses 0-indexed month, so month - 1
        const date = new Date(year, month - 1, day);

        // Handle potentially invalid dates
        if (isNaN(date)) {
          return { sortKey: "9999-99-99", headerDisplay: "Invalid Date" };
        }

        const displayMonth = date.toLocaleString("en-US", { month: "short" });
        const displayDay = day.padStart(2, "0");
        const sortKey = `${year}-${month.padStart(2, "0")}-${displayDay}`;
        const headerDisplay = `${displayMonth}-${displayDay}`;

        return { sortKey, headerDisplay };
      }

      // --- Core Application Logic ---

      function updateUI(message = "", isError = false) {
        const msgEl = document.getElementById("message");
        msgEl.textContent = message;
        msgEl.classList.remove("hidden", "text-red-500", "text-gray-500");
        msgEl.classList.add(isError ? "text-red-500" : "text-gray-500");
        if (message === "") msgEl.classList.add("hidden");
      }

      function processCSV() {
        const fileInput = document.getElementById("csvFile");
        const outputArea = document.getElementById("csvOutput");
        const downloadBtn = document.getElementById("downloadButton");

        outputArea.value = "Processing...";
        downloadBtn.disabled = true;
        updateUI("");

        const file = fileInput.files[0];
        if (!file) {
          outputArea.value = "";
          updateUI("Please select a CSV file first.", true);
          return;
        }

        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            const rawData = e.target.result;
            const parsedData = parseCSV(rawData);

            if (parsedData.length === 0) {
              updateUI("CSV file is empty or unreadable.", true);
              outputArea.value = "";
              return;
            }

            // Index mapping based on the provided CSV sample (0-indexed)
            const ADMIN_INDEX = 4;
            const NAME_INDEX = 3;
            const ACTIVITY_TYPE_INDEX = 5;
            const DATE_INDEX = 6;
            const DIVISION_INDEX = 11; // Index for the "Division" column

            // Specific dates the user confirmed are official Chinese Chess training sessions
            // DD/MM/YYYY format based on input CSV
            const requiredDates = new Set([
              "07/11/2025",
              "21/11/2025",
              "28/11/2025",
            ]);

            // 1. Filter for 'Training/Workshop' AND 'Chinese Chess' division AND required dates
            const trainingRecords = parsedData.filter((row) => {
              // Check if row has enough columns
              const hasRequiredData =
                row.length > DIVISION_INDEX && row.length > DATE_INDEX;
              if (!hasRequiredData) return false;

              const isTraining =
                row[ACTIVITY_TYPE_INDEX] &&
                row[ACTIVITY_TYPE_INDEX].toLowerCase() === "training/workshop";
              const isChineseChess =
                row[DIVISION_INDEX] &&
                row[DIVISION_INDEX].toLowerCase() === "chinese chess";
              const isRequiredDate =
                row[DATE_INDEX] && requiredDates.has(row[DATE_INDEX]); // Check against the exact date string

              // Only include records that satisfy ALL three conditions
              return isTraining && isChineseChess && isRequiredDate;
            });

            if (trainingRecords.length === 0) {
              updateUI(
                'No relevant "Chinese Chess" training records found on the specified dates (7/11, 21/11, 28/11) in the CSV.',
                true
              );
              outputArea.value = "";
              return;
            }

            const studentAttendance = {};
            const uniqueDates = new Set();

            // 2. Build student attendance map and collect unique dates
            trainingRecords.forEach((row) => {
              const adminNo = row[ADMIN_INDEX];
              const name = row[NAME_INDEX];
              const dateStr = row[DATE_INDEX];

              if (adminNo && name && dateStr) {
                const { sortKey } = formatDate(dateStr);
                uniqueDates.add(sortKey); // Add sortable date to set

                if (!studentAttendance[adminNo]) {
                  // Clean up the name by removing leading/trailing quotes if parseCSV missed any
                  studentAttendance[adminNo] = {
                    name: name.replace(/^"|"$/g, ""),
                    attendance: {},
                    totalAttended: 0,
                  };
                }
                // Mark attendance for this date (ensures uniqueness per student per day)
                studentAttendance[adminNo].attendance[sortKey] = 1;
              }
            });

            // 3. Prepare the student data array
            // Sorting the dates will ensure the output columns are in chronological order
            const sortedDates = Array.from(uniqueDates).sort();
            const uniqueTrainingCount = sortedDates.length;
            const finalOutput = [];

            Object.keys(studentAttendance)
              .sort()
              .forEach((adminNo) => {
                const student = studentAttendance[adminNo];
                let totalAttended = 0;
                const dateAttendance = {};

                // Calculate total attendance and percentage
                sortedDates.forEach((sortKey) => {
                  const attended = student.attendance[sortKey] || 0;
                  dateAttendance[sortKey] = attended;
                  totalAttended += attended;
                });

                // Now uses the globally scoped uniqueTrainingCount
                const percentage =
                  uniqueTrainingCount > 0
                    ? Math.round((totalAttended / uniqueTrainingCount) * 100)
                    : 0;

                // Create the final data row
                const dataRow = [
                  adminNo,
                  student.name,
                  totalAttended,
                  percentage,
                ];

                // Append the date-specific attendance flags
                sortedDates.forEach((sortKey) => {
                  dataRow.push(dateAttendance[sortKey]);
                });

                finalOutput.push(dataRow);
              });

            // 4. Generate the two-row CSV header
            const dateHeadersDisplay = sortedDates.map((sortKey) => {
              // Find the original date string corresponding to the sortKey
              const originalRecord = trainingRecords.find(
                (r) => formatDate(r[DATE_INDEX]).sortKey === sortKey
              );
              if (originalRecord) {
                return formatDate(originalRecord[DATE_INDEX]).headerDisplay;
              }
              // Fallback if record somehow isn't found (shouldn't happen)
              return "N/A";
            });

            const header1 = [
              "Admin Number",
              "Name",
              "Total",
              "Percentage",
              "Trainings Attended",
              ...Array(dateHeadersDisplay.length - 1).fill(""),
            ].join(",");

            const header2 = ["", "", "", "", ...dateHeadersDisplay].join(",");

            // 5. Combine all parts into the final CSV string
            const csvContent = [
              header1,
              header2,
              ...finalOutput.map((row) => row.join(",")),
            ].join("\n");

            outputArea.value = csvContent;
            downloadBtn.disabled = false;
            updateUI(
              `Report generated successfully for the ${uniqueTrainingCount} Chinese Chess trainings you specified.`,
              false
            );
          } catch (error) {
            console.error("Error processing CSV:", error);
            outputArea.value = "";
            updateUI(
              `An error occurred during processing: ${error.message}. Please check your CSV file format.`,
              true
            );
          }
        };

        reader.onerror = () => {
          outputArea.value = "";
          updateUI("Error reading file. Please try again.", true);
        };

        reader.readAsText(file);
      }

      // --- Download Function ---

      function downloadCSV() {
        const csvText = document.getElementById("csvOutput").value;
        if (!csvText) {
          updateUI("No data to download.", true);
          return;
        }

        const blob = new Blob([csvText], { type: "text/csv;charset=utf-8;" });
        const link = document.createElement("a");

        // Fallback for browsers
        if (link.download !== undefined) {
          const url = URL.createObjectURL(blob);
          link.setAttribute("href", url);
          link.setAttribute("download", "chinese_chess_attendance_report.csv");
          link.style.visibility = "hidden";
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        } else {
          // Use custom modal instead of alert
          updateUI(
            "Your browser does not support direct download. Please copy the text from the box.",
            true
          );
        }
      }
    </script>
  </body>
</html>
