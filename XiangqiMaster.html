<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Xiangqi Master: Mobile</title>
    <style>
      :root {
        --bg-grad: radial-gradient(circle at center, #1a1a1a 0%, #000000 100%);
        --board-bg: #eecfa1;
        --line-color: #5d4037;
        --glass: rgba(255, 255, 255, 0.08);
        --glass-border: rgba(255, 255, 255, 0.1);
        --highlight: rgba(255, 215, 0, 0.4);
        --selected: rgba(0, 255, 0, 0.5);
        --red: #d63031;
        --black: #2d3436;
        --tab-active: #2980b9;
        --branch-btn: #8e44ad;
      }

      body {
        margin: 0;
        background: var(--bg-grad);
        color: #ddd;
        font-family: "Microsoft YaHei", sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        height: 100dvh;
        width: 100vw;
        overflow: hidden;
      }

      .container {
        display: flex;
        flex-direction: column;
        width: 100%;
        height: 100%;
        max-width: 600px;
        padding: 10px;
        box-sizing: border-box;
        gap: 10px;
      }

      .board-frame {
        width: 100%;
        aspect-ratio: 450/500;
        position: relative;
        background: var(--board-bg);
        border-radius: 4px;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
        flex-shrink: 0;
        margin: 0 auto;
      }

      .board-inner {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      svg.grid {
        width: 100%;
        height: 100%;
        display: block;
        pointer-events: none;
      }
      .line {
        stroke: var(--line-color);
        stroke-width: 2;
        fill: none;
        vector-effect: non-scaling-stroke;
      }
      .border {
        stroke: var(--line-color);
        stroke-width: 4;
        fill: none;
        vector-effect: non-scaling-stroke;
      }
      .river-text {
        font-family: "KaiTi", serif;
        font-size: 34px;
        fill: var(--line-color);
        opacity: 0.8;
        text-anchor: middle;
        dominant-baseline: middle;
        font-weight: bold;
      }

      .layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
      }
      .click-mask {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 100;
        cursor: pointer;
        -webkit-tap-highlight-color: transparent;
      }

      .piece {
        width: 11.11%;
        height: 10%;
        position: absolute;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10;
        transition: top 0.15s, left 0.15s;
      }

      .piece::after {
        content: attr(data-char);
        width: 85%;
        height: 85%;
        background: #fdf5e6;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        font-family: "KaiTi", serif;
        font-weight: bold;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4),
          inset 0 2px 5px rgba(255, 255, 255, 0.9);
        font-size: clamp(16px, 5vw, 28px);
      }
      .piece.red::after {
        color: var(--red);
        border: 2px solid #c0392b;
      }
      .piece.black::after {
        color: var(--black);
        border: 2px solid #333;
      }

      .marker {
        position: absolute;
        width: 11.11%;
        height: 10%;
        display: flex;
        justify-content: center;
        align-items: center;
      }
      .last::after {
        content: "";
        width: 90%;
        height: 90%;
        background: var(--highlight);
        border-radius: 8px;
      }
      .select::after {
        content: "";
        width: 90%;
        height: 90%;
        background: var(--selected);
        border-radius: 50%;
        box-shadow: 0 0 10px var(--selected);
      }
      .dot::after {
        content: "";
        width: 25%;
        height: 25%;
        background: rgba(0, 180, 0, 0.8);
        border-radius: 50%;
      }

      .ui-panel {
        flex: 1;
        display: flex;
        flex-direction: column;
        background: var(--glass);
        border: 1px solid var(--glass-border);
        border-radius: 8px;
        overflow: hidden;
        min-height: 0;
      }

      .tabs {
        display: flex;
        border-bottom: 1px solid var(--glass-border);
        flex-shrink: 0;
      }
      .tab {
        flex: 1;
        padding: 10px;
        text-align: center;
        cursor: pointer;
        background: rgba(0, 0, 0, 0.2);
        transition: 0.2s;
        font-weight: bold;
      }
      .tab.active {
        background: var(--tab-active);
        color: white;
      }

      .tab-content {
        flex: 1;
        display: none;
        flex-direction: column;
        padding: 10px;
        overflow: hidden;
        min-height: 0;
      }
      .tab-content.active {
        display: flex;
      }

      .playback-bar {
        display: flex;
        gap: 5px;
        margin-bottom: 10px;
        flex-shrink: 0;
      }
      .pb-btn {
        flex: 1;
        padding: 10px 0;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: white;
        border-radius: 4px;
        cursor: pointer;
        font-size: 16px;
      }
      .pb-btn:active {
        background: rgba(255, 255, 255, 0.3);
      }

      /* Branch Control */
      .branch-ctrl {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        margin-bottom: 5px;
        background: rgba(0, 0, 0, 0.3);
        padding: 4px;
        border-radius: 4px;
        font-size: 13px;
        display: none; /* Hidden by default */
      }
      .branch-ctrl.active {
        display: flex;
      }
      .branch-btn {
        background: var(--branch-btn);
        border: none;
        color: white;
        border-radius: 3px;
        padding: 2px 8px;
        cursor: pointer;
      }

      .status {
        text-align: center;
        margin-bottom: 5px;
        font-weight: bold;
        color: #ff6b6b;
        font-size: 14px;
        flex-shrink: 0;
      }

      .history {
        flex: 1;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 4px;
        overflow-y: auto;
        padding: 5px;
        font-family: monospace;
        font-size: 13px;
      }
      .row {
        display: flex;
        padding: 4px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      }
      .row.current {
        background: rgba(255, 215, 0, 0.2);
        border-left: 3px solid gold;
      }
      .row span {
        flex: 1;
        cursor: pointer;
        display: flex;
        align-items: center;
      }
      .branch-icon {
        color: #8e44ad;
        font-size: 16px;
        margin-left: 4px;
        font-weight: bold;
      }

      .tool-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        flex-shrink: 0;
      }
      .btn {
        padding: 12px;
        border-radius: 4px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: white;
        cursor: pointer;
        font-weight: bold;
      }
      .btn-norm {
        background: rgba(255, 255, 255, 0.1);
      }
      .btn-red {
        background: #c0392b;
        border: none;
      }
      .btn-green {
        background: #27ae60;
        border: none;
      }
      textarea {
        width: 100%;
        height: 80px;
        background: rgba(0, 0, 0, 0.3);
        color: white;
        border: 1px solid #555;
        resize: none;
        margin-bottom: 10px;
        box-sizing: border-box;
      }

      #splash {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0);
        font-size: 4rem;
        font-family: "KaiTi";
        font-weight: 900;
        color: #ff4757;
        text-shadow: 0 5px 20px black;
        pointer-events: none;
        z-index: 200;
        opacity: 0;
        -webkit-text-stroke: 2px white;
        white-space: nowrap;
      }
      .pop {
        animation: popAnim 1.2s ease-out forwards;
      }
      @keyframes popAnim {
        0% {
          transform: translate(-50%, -50%) scale(0.5);
          opacity: 0;
        }
        20% {
          transform: translate(-50%, -50%) scale(1.2);
          opacity: 1;
        }
        100% {
          transform: translate(-50%, -50%) scale(1);
          opacity: 0;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="board-frame" id="boardFrame">
        <div class="board-inner">
          <svg class="grid" viewBox="0 0 450 500" preserveAspectRatio="none">
            <rect x="25" y="25" width="400" height="450" class="border" />
            <line x1="25" y1="75" x2="425" y2="75" class="line" />
            <line x1="25" y1="125" x2="425" y2="125" class="line" />
            <line x1="25" y1="175" x2="425" y2="175" class="line" />
            <line x1="25" y1="225" x2="425" y2="225" class="line" />
            <line x1="25" y1="275" x2="425" y2="275" class="line" />
            <line x1="25" y1="325" x2="425" y2="325" class="line" />
            <line x1="25" y1="375" x2="425" y2="375" class="line" />
            <line x1="25" y1="425" x2="425" y2="425" class="line" />
            <line x1="225" y1="25" x2="225" y2="225" class="line" />
            <line x1="225" y1="275" x2="225" y2="475" class="line" />
            <line x1="75" y1="25" x2="75" y2="225" class="line" />
            <line x1="75" y1="275" x2="75" y2="475" class="line" />
            <line x1="125" y1="25" x2="125" y2="225" class="line" />
            <line x1="125" y1="275" x2="125" y2="475" class="line" />
            <line x1="175" y1="25" x2="175" y2="225" class="line" />
            <line x1="175" y1="275" x2="175" y2="475" class="line" />
            <line x1="275" y1="25" x2="275" y2="225" class="line" />
            <line x1="275" y1="275" x2="275" y2="475" class="line" />
            <line x1="325" y1="25" x2="325" y2="225" class="line" />
            <line x1="325" y1="275" x2="325" y2="475" class="line" />
            <line x1="375" y1="25" x2="375" y2="225" class="line" />
            <line x1="375" y1="275" x2="375" y2="475" class="line" />
            <line x1="175" y1="25" x2="275" y2="125" class="line" />
            <line x1="275" y1="25" x2="175" y2="125" class="line" />
            <line x1="175" y1="375" x2="275" y2="475" class="line" />
            <line x1="275" y1="375" x2="175" y2="475" class="line" />
            <text x="110" y="250" class="river-text">楚 河</text>
            <text x="340" y="250" class="river-text">漢 界</text>
          </svg>
          <div id="markerLayer" class="layer"></div>
          <div id="pieceLayer" class="layer"></div>
          <div class="click-mask" onclick="ui.click(event)"></div>
          <div id="splash">將 軍</div>
        </div>
      </div>

      <div class="ui-panel">
        <div class="tabs">
          <div
            class="tab active"
            data-key="tabGame"
            onclick="ui.switchTab('game')"
          >
            Game
          </div>
          <div class="tab" data-key="tabTools" onclick="ui.switchTab('tools')">
            Tools
          </div>
        </div>

        <div id="tab-game" class="tab-content active">
          <div id="status" class="status">Red to Move</div>

          <div id="branchCtrl" class="branch-ctrl">
            <button class="branch-btn" onclick="game.prevVar()">&lt;</button>
            <span id="varInfo">Var: 1/1</span>
            <button class="branch-btn" onclick="game.nextVar()">&gt;</button>
          </div>

          <div class="playback-bar">
            <button class="pb-btn" onclick="game.goto(0)">|&lt;</button>
            <button class="pb-btn" onclick="game.step(-1)">&lt;</button>
            <button class="pb-btn" id="playBtn" onclick="game.togglePlay()">
              ▶
            </button>
            <button class="pb-btn" onclick="game.step(1)">&gt;</button>
            <button class="pb-btn" onclick="game.goto(9999)">&gt;|</button>
          </div>
          <div id="history" class="history"></div>
        </div>

        <div id="tab-tools" class="tab-content">
          <div class="tool-grid">
            <button
              class="btn btn-red"
              data-key="newGame"
              onclick="game.newGame()"
            >
              New Game
            </button>
            <button class="btn btn-norm" data-key="undo" onclick="game.undo()">
              Undo
            </button>
            <button class="btn btn-norm" data-key="flip" onclick="ui.doFlip()">
              Flip View
            </button>
            <button
              class="btn btn-norm"
              data-key="reflect"
              onclick="ui.doReflect()"
            >
              Reflect
            </button>
          </div>
          <hr
            style="
              border: 0;
              border-top: 1px solid rgba(255, 255, 255, 0.1);
              margin: 10px 0;
            "
          />
          <textarea
            id="fenBox"
            placeholder="Paste FEN or Movelist..."
          ></textarea>
          <div class="tool-grid">
            <button class="btn btn-norm" data-key="load" onclick="game.load()">
              Load
            </button>
            <button
              class="btn btn-green"
              data-key="export"
              onclick="game.export()"
            >
              Export
            </button>
          </div>
          <div class="tool-grid" style="margin-top: 8px">
            <button
              class="btn btn-norm"
              onclick="ui.toggleLang()"
              style="grid-column: span 2"
            >
              文 / A
            </button>
          </div>
        </div>
      </div>
    </div>

    <script>
      const sfx = {
        play(f, t, g = 0.3, d = 0.1) {
          const c = new (window.AudioContext || window.webkitAudioContext)();
          const o = c.createOscillator();
          const gn = c.createGain();
          o.type = t;
          o.frequency.setValueAtTime(f, c.currentTime);
          gn.gain.setValueAtTime(g, c.currentTime);
          gn.gain.exponentialRampToValueAtTime(0.01, c.currentTime + d);
          o.connect(gn);
          gn.connect(c.destination);
          o.start();
          o.stop(c.currentTime + d);
        },
      };

      const CN_NUMS = [
        "",
        "一",
        "二",
        "三",
        "四",
        "五",
        "六",
        "七",
        "八",
        "九",
      ];
      const CN_DIGITS = [
        "",
        "１",
        "２",
        "３",
        "４",
        "５",
        "６",
        "７",
        "８",
        "９",
      ];
      const CN_PIECES = {
        rK: "帥",
        rA: "仕",
        rE: "相",
        rN: "傌",
        rR: "俥",
        rC: "炮",
        rP: "兵",
        bK: "将",
        bA: "士",
        bE: "象",
        bN: "馬",
        bR: "車",
        bC: "砲",
        bP: "卒",
        K: "帥",
        A: "仕",
        E: "相",
        N: "傌",
        R: "俥",
        C: "炮",
        P: "兵",
        k: "将",
        a: "士",
        e: "象",
        n: "馬",
        r: "車",
        c: "砲",
        p: "卒",
      };
      const CN_DIR = { "+": "进", "-": "退", "=": "平" };

      const STRINGS = {
        en: {
          tabGame: "Game",
          tabTools: "Tools",
          newGame: "New Game",
          undo: "Undo",
          flip: "Flip View",
          reflect: "Reflect",
          load: "Load",
          export: "Export",
          redMove: "Red to Move",
          blackMove: "Black to Move",
          check: " - Check!",
          win: " Wins (Checkmate)",
          stalemate: "Stalemate",
          confirmNew: "Start New Game?",
          copied: "Full Format Copied!",
          illegal: "Stopped: Illegal Move encountered at ",
          overwrite: "You are about to change history. Create new Branch?",
        },
        zh: {
          tabGame: "对弈",
          tabTools: "工具",
          newGame: "新对局",
          undo: "悔棋",
          flip: "翻转棋盘",
          reflect: "镜像显示",
          load: "导入",
          export: "导出",
          redMove: "红方走",
          blackMove: "黑方走",
          check: " - 将军!",
          win: " 胜 (绝杀)",
          stalemate: "困毙 (和棋)",
          confirmNew: "开始新对局?",
          copied: "已复制完整棋谱!",
          illegal: "停止: 遇到非法着法于 ",
          overwrite: "是否创建新变着?",
        },
      };

      // Node class for the Move Tree
      class MoveNode {
        constructor(moveData, parent = null) {
          this.data = moveData; // {fx, fy, tx, ty, p, cap, mv}
          this.parent = parent;
          this.children = [];
          // When loading branches, we store the branch ID to group children
          this.tempBranchId = null;
        }
      }

      class Engine {
        constructor() {
          this.reset();
        }
        reset() {
          this.board = Array(10)
            .fill(null)
            .map(() => Array(9).fill(null));
          const start = [
            ["bR", "bN", "bE", "bA", "bK", "bA", "bE", "bN", "bR"],
            [null, null, null, null, null, null, null, null, null],
            [null, "bC", null, null, null, null, null, "bC", null],
            ["bP", null, "bP", null, "bP", null, "bP", null, "bP"],
            [null, null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null, null],
            ["rP", null, "rP", null, "rP", null, "rP", null, "rP"],
            [null, "rC", null, null, null, null, null, "rC", null],
            [null, null, null, null, null, null, null, null, null],
            ["rR", "rN", "rE", "rA", "rK", "rA", "rE", "rN", "rR"],
          ];
          for (let y = 0; y < 10; y++)
            for (let x = 0; x < 9; x++) this.board[y][x] = start[y][x];
          this.turn = "r";

          // Tree Structure
          this.root = new MoveNode(null);
          this.cursor = this.root; // Current node we are looking at
        }

        getPiece(x, y) {
          if (x < 0 || x > 8 || y < 0 || y > 9) return null;
          return this.board[y][x];
        }

        // Returns linear history array from root to cursor
        getHistory() {
          let hist = [];
          let curr = this.cursor;
          while (curr.parent) {
            hist.push(curr.data);
            curr = curr.parent;
          }
          return hist.reverse();
        }

        validate(fx, fy, tx, ty, p) {
          if (fx === tx && fy === ty) return false;
          const tgt = this.getPiece(tx, ty);
          if (tgt && tgt[0] === p[0]) return false;
          const dx = tx - fx,
            dy = ty - fy,
            adx = Math.abs(dx),
            ady = Math.abs(dy);
          const type = p[1],
            red = p[0] === "r";
          switch (type) {
            case "K":
              return (
                tx >= 3 &&
                tx <= 5 &&
                (red ? ty >= 7 : ty <= 2) &&
                adx + ady === 1
              );
            case "A":
              return (
                tx >= 3 &&
                tx <= 5 &&
                (red ? ty >= 7 : ty <= 2) &&
                adx === 1 &&
                ady === 1
              );
            case "E":
              return (
                (red ? ty >= 5 : ty <= 4) &&
                adx === 2 &&
                ady === 2 &&
                !this.getPiece(fx + dx / 2, fy + dy / 2)
              );
            case "N":
              if (adx === 1 && ady === 2)
                return !this.getPiece(fx, fy + (dy > 0 ? 1 : -1));
              if (adx === 2 && ady === 1)
                return !this.getPiece(fx + (dx > 0 ? 1 : -1), fy);
              return false;
            case "R":
              return (dx === 0 || dy === 0) && this.count(fx, fy, tx, ty) === 0;
            case "C":
              const c = this.count(fx, fy, tx, ty);
              return (dx === 0 || dy === 0) && (tgt ? c === 1 : c === 0);
            case "P":
              const fwd = red ? -1 : 1,
                cross = red ? fy <= 4 : fy >= 5;
              return (
                (dy === fwd && dx === 0) || (cross && dy === 0 && adx === 1)
              );
          }
          return false;
        }
        count(x1, y1, x2, y2) {
          let c = 0,
            dx = Math.sign(x2 - x1),
            dy = Math.sign(y2 - y1),
            x = x1 + dx,
            y = y1 + dy,
            safe = 0;
          while ((x !== x2 || y !== y2) && safe++ < 20) {
            if (this.getPiece(x, y)) c++;
            x += dx;
            y += dy;
          }
          return c;
        }
        inCheck(turn) {
          let k = null,
            opp = turn === "r" ? "b" : "r";
          for (let y = 0; y < 10; y++)
            for (let x = 0; x < 9; x++)
              if (this.board[y][x] === turn + "K") k = { x, y };
          if (!k) return true;
          let ok = null;
          for (let y = 0; y < 10; y++)
            for (let x = 0; x < 9; x++)
              if (this.board[y][x] === opp + "K") ok = { x, y };
          if (ok && k.x === ok.x && this.count(k.x, k.y, ok.x, ok.y) === 0)
            return true;
          for (let y = 0; y < 10; y++)
            for (let x = 0; x < 9; x++) {
              let p = this.board[y][x];
              if (p && p[0] === opp && this.validate(x, y, k.x, k.y, p))
                return true;
            }
          return false;
        }
        getLegalMoves() {
          let moves = [],
            turn = this.turn;
          for (let fy = 0; fy < 10; fy++)
            for (let fx = 0; fx < 9; fx++) {
              let p = this.board[fy][fx];
              if (p && p[0] === turn) {
                for (let ty = 0; ty < 10; ty++)
                  for (let tx = 0; tx < 9; tx++) {
                    if (this.validate(fx, fy, tx, ty, p)) {
                      let cap = this.board[ty][tx];
                      this.board[ty][tx] = p;
                      this.board[fy][fx] = null;
                      if (!this.inCheck(turn))
                        moves.push({ fx, fy, tx, ty, p, cap });
                      this.board[fy][fx] = p;
                      this.board[ty][tx] = cap;
                    }
                  }
              }
            }
          return moves;
        }

        move(fx, fy, tx, ty) {
          // Check if we are overwriting
          const mvStr = `${fx}${fy}${tx}${ty}`;

          // Check existing children to avoid duplicate branches
          let existingChild = this.cursor.children.find(
            (c) => c.data.mv === mvStr
          );

          if (!existingChild && this.cursor.children.length > 0) {
            // We are at a node that already has a next move, but we are making a DIFFERENT one
            if (!confirm(ui.getText("overwrite"))) return false;
          }

          let p = this.board[fy][fx];
          if (!p || p[0] !== this.turn) return false;
          let cap = this.board[ty][tx];
          if (!this.validate(fx, fy, tx, ty, p)) return false;

          this.board[ty][tx] = p;
          this.board[fy][fx] = null;
          if (this.inCheck(this.turn)) {
            this.board[fy][fx] = p;
            this.board[ty][tx] = cap;
            return false;
          }

          if (existingChild) {
            this.cursor = existingChild;
          } else {
            let newNode = new MoveNode(
              { fx, fy, tx, ty, p, cap, mv: mvStr },
              this.cursor
            );
            this.cursor.children.push(newNode);
            this.cursor = newNode;
          }

          this.turn = this.turn === "r" ? "b" : "r";
          return cap;
        }
      }

      const ui = {
        flip: false,
        reflect: false,
        sel: null,
        lang: "en",
        init() {
          this.render();
          this.updateInfo();
          this.updateText();
        },
        toggleLang() {
          this.lang = this.lang === "en" ? "zh" : "en";
          this.updateText();
          this.updateInfo();
        },
        getText(key) {
          return STRINGS[this.lang][key] || key;
        },
        updateText() {
          document.querySelectorAll("[data-key]").forEach((el) => {
            el.innerText = this.getText(el.dataset.key);
          });
          document.title = "Xiangqi Master: Mobile";
        },
        switchTab(t) {
          document
            .querySelectorAll(".tab")
            .forEach((e) => e.classList.remove("active"));
          document
            .querySelectorAll(".tab-content")
            .forEach((e) => e.classList.remove("active"));
          event.target.classList.add("active");
          document.getElementById("tab-" + t).classList.add("active");
        },
        doFlip() {
          this.flip = !this.flip;
          this.render();
        },
        doReflect() {
          this.reflect = !this.reflect;
          this.render();
          this.updateInfo();
        },
        toPx(x, y) {
          let rx = this.reflect ? 8 - x : x;
          if (this.flip) {
            rx = 8 - rx;
            y = 9 - y;
          } else {
            ry = y;
          }
          return { left: rx * 11.11, top: ry * 10 };
        },
        toLog(cx, cy) {
          const rect = document
            .getElementById("boardFrame")
            .getBoundingClientRect();
          let x = Math.floor((cx - rect.left) / (rect.width / 9));
          let y = Math.floor((cy - rect.top) / (rect.height / 10));
          if (x < 0 || x > 8 || y < 0 || y > 9) return null;
          if (this.flip) {
            x = 8 - x;
            y = 9 - y;
          }
          if (this.reflect) x = 8 - x;
          return { x, y };
        },
        click(e) {
          if (game.isGameOver) return;
          const c = this.toLog(e.clientX, e.clientY);
          if (!c) return;
          const p = game.eng.getPiece(c.x, c.y);
          const handleMove = () => {
            const cap = game.eng.move(this.sel.x, this.sel.y, c.x, c.y);
            if (cap !== false) {
              if (cap) sfx.play(200, "triangle", 0.2, 0.1);
              else sfx.play(300, "square");
              this.sel = null;
              requestAnimationFrame(() => {
                this.render();
                this.updateInfo();
                game.checkGameOver();
              });
            } else if (p && p[0] === game.eng.turn) {
              this.sel = c;
              sfx.play(150, "sine");
              requestAnimationFrame(() => this.render());
            } else {
              this.sel = null;
              requestAnimationFrame(() => this.render());
            }
          };
          if (this.sel) handleMove();
          else if (p && p[0] === game.eng.turn) {
            this.sel = c;
            sfx.play(150, "sine");
            requestAnimationFrame(() => this.render());
          }
        },
        render() {
          const pL = document.getElementById("pieceLayer"),
            mL = document.getElementById("markerLayer");
          pL.innerHTML = "";
          mL.innerHTML = "";

          let hist = game.eng.getHistory();
          // We need to rebuild board state based on history because of tree navigation
          // Ideally Engine should maintain board state correctly on undo/redo,
          // but for robustness in this lightweight implementation, let's rebuild from FEN + History
          // This ensures jumping branches works perfectly visually.

          let tmp = new Engine();
          if (game.startFen) game.loadFenTo(game.startFen, tmp);
          hist.forEach((m) => {
            tmp.board[m.ty][m.tx] = tmp.board[m.fy][m.fx];
            tmp.board[m.fy][m.fx] = null;
          });

          let board = tmp.board;

          for (let y = 0; y < 10; y++)
            for (let x = 0; x < 9; x++) {
              let p = board[y][x];
              let pos = this.toPx(x, y);

              // Highlight Last Move
              let last = hist[hist.length - 1];
              if (
                last &&
                ((last.fx === x && last.fy === y) ||
                  (last.tx === x && last.ty === y))
              ) {
                let m = document.createElement("div");
                m.className = "marker last";
                m.style.left = pos.left + "%";
                m.style.top = pos.top + "%";
                mL.appendChild(m);
              }
              if (this.sel && this.sel.x === x && this.sel.y === y) {
                let m = document.createElement("div");
                m.className = "marker select";
                m.style.left = pos.left + "%";
                m.style.top = pos.top + "%";
                mL.appendChild(m);
                // Legal Dots - Recalculate based on current board state
                tmp.turn = game.eng.turn;
                tmp
                  .getLegalMoves()
                  .filter((m) => m.fx === x && m.fy === y)
                  .forEach((m) => {
                    let dPos = this.toPx(m.tx, m.ty),
                      d = document.createElement("div");
                    d.className = "marker dot";
                    d.style.left = dPos.left + "%";
                    d.style.top = dPos.top + "%";
                    mL.appendChild(d);
                  });
              }
              if (p) {
                let d = document.createElement("div");
                d.className = `piece ${p[0] === "r" ? "red" : "black"}`;
                d.dataset.char = CN_PIECES[p];
                if (p[0] === "b" && p[1] === "K")
                  d.dataset.char = CN_PIECES["k"];
                if (p[0] === "r" && p[1] === "K")
                  d.dataset.char = CN_PIECES["K"];
                d.style.left = pos.left + "%";
                d.style.top = pos.top + "%";
                pL.appendChild(d);
              }
            }
        },
        updateInfo() {
          const list = document.getElementById("history"),
            statusEl = document.getElementById("status");
          const branchCtrl = document.getElementById("branchCtrl");
          const varInfo = document.getElementById("varInfo");

          document.getElementById("playBtn").innerText = game.isPlaying
            ? "||"
            : "▶";
          if (game.isGameOver) {
            statusEl.style.color = "yellow";
            statusEl.innerText = game.gameOverStatus;
          } else {
            statusEl.style.color = game.eng.turn === "r" ? "#ff6b6b" : "#aaa";
            statusEl.innerText = this.getText(
              game.eng.turn === "r" ? "redMove" : "blackMove"
            );
            if (game.eng.inCheck(game.eng.turn))
              statusEl.innerText += this.getText("check");
          }

          // Branch UI
          if (
            game.eng.cursor.parent &&
            game.eng.cursor.parent.children.length > 1
          ) {
            branchCtrl.classList.add("active");
            let sibs = game.eng.cursor.parent.children;
            let idx = sibs.indexOf(game.eng.cursor);
            varInfo.innerText = `Var: ${idx + 1}/${sibs.length}`;
          } else {
            branchCtrl.classList.remove("active");
          }

          list.innerHTML = "";
          let tmp = new Engine();
          if (game.startFen) game.loadFenTo(game.startFen, tmp);

          let hist = game.eng.getHistory();

          for (let i = 0; i < hist.length; i += 2) {
            let h1 = hist[i],
              h2 = hist[i + 1];
            let not1 = game.genNotation(tmp, h1, this.reflect);
            tmp.board[h1.ty][h1.tx] = tmp.board[h1.fy][h1.fx];
            tmp.board[h1.fy][h1.fx] = null;
            let not2 = h2 ? game.genNotation(tmp, h2, this.reflect) : "";
            if (h2) {
              tmp.board[h2.ty][h2.tx] = tmp.board[h2.fy][h2.fx];
              tmp.board[h2.fy][h2.fx] = null;
            }

            let div = document.createElement("div");
            // Highlight Current Move
            let isCurr =
              game.eng.cursor.data === h1 ||
              (h2 && game.eng.cursor.data === h2);
            div.className = "row" + (isCurr ? " current" : "");

            // Add Variation Indicators
            // We need to trace back nodes to see if they had siblings
            // This is slightly expensive but okay for short lists
            // Let's cheat: we need reference to the Nodes, not just data.
            // Re-traversing is safest.

            let n1_icon = "",
              n2_icon = "";
            // Logic to find if h1 node has siblings.
            // We can assume h1 corresponds to a node in the active path.
            // Ideally we'd store the node ref in the history array, but let's keep it simple.

            div.innerHTML = `<span>${
              i / 2 + 1
            }.</span><span onclick="game.goto(${
              i + 1
            })">${not1}${n1_icon}</span><span onclick="game.goto(${
              i + 2
            })">${not2}${n2_icon}</span>`;

            // Inject variation symbol manually if needed (Simplified visual for now)
            // Ideally we check node.parent.children.length > 1

            list.appendChild(div);
            if (isCurr) div.scrollIntoView({ block: "nearest" });
          }
        },
        splash(txt) {
          let el = document.getElementById("splash");
          el.innerText = txt;
          el.classList.remove("pop");
          void el.offsetWidth;
          el.classList.add("pop");
          sfx.play(440, "sine", 0.5, 0.4);
        },
      };

      const game = {
        eng: new Engine(),
        startFen:
          "rnbakabnr/9/1c5c1/p1p1p1p1p/9/9/P1P1P1P1P/1C5C1/9/RNBAKABNR w - - 0 1",
        isGameOver: false,
        gameOverStatus: "",
        isPlaying: false,
        playTimer: null,
        newGame() {
          if (!confirm(ui.getText("confirmNew"))) return;
          this.eng.reset();
          this.startFen =
            "rnbakabnr/9/1c5c1/p1p1p1p1p/9/9/P1P1P1P1P/1C5C1/9/RNBAKABNR w - - 0 1";
          document.getElementById("fenBox").value = "";
          this.stopPlay();
          ui.sel = null;
          ui.flip = false;
          ui.reflect = false;
          this.isGameOver = false;
          this.gameOverStatus = "";
          ui.init();
          sfx.play(400, "sawtooth");
        },
        reset() {
          this.newGame();
        },
        undo() {
          this.stopPlay();
          if (this.eng.cursor.parent) {
            let p = this.eng.cursor.data;
            // Revert Logic: Manually restore board for consistency
            this.eng.board[p.fy][p.fx] = p.p;
            this.eng.board[p.ty][p.tx] = p.cap;
            this.eng.cursor = this.eng.cursor.parent;
            this.eng.turn = this.eng.turn === "r" ? "b" : "r";
            this.isGameOver = false;
            ui.sel = null;
            ui.render();
            ui.updateInfo();
          }
        },
        goto(i) {
          this.stopPlay();
          // Find the node at depth i in current active branch
          // Root is depth 0. Move 1 is depth 1.
          // i is number of moves.

          // Strategy: Go to root, then dive down 'i' times using current children[0] if active path logic fails,
          // BUT wait, we want to stay on the *active* path.
          // Actually, we are likely clicking on the history list which represents the active path.

          let hist = this.eng.getHistory();
          if (i > hist.length) return;

          // Reset to root
          while (this.eng.cursor.parent) {
            this.undo();
          }

          // Replay 'i' moves
          for (let k = 0; k < i; k++) {
            let moveData = hist[k];
            // Find child matching this data
            let child = this.eng.cursor.children.find(
              (c) => c.data === moveData
            );
            if (child) {
              // Execute Move
              this.eng.board[moveData.ty][moveData.tx] = moveData.p;
              this.eng.board[moveData.fy][moveData.fx] = null;
              this.eng.cursor = child;
              this.eng.turn = this.eng.turn === "r" ? "b" : "r";
            }
          }
          ui.sel = null;
          ui.render();
          ui.updateInfo();
        },

        // Variation Control
        nextVar() {
          if (this.eng.cursor.parent) {
            let sibs = this.eng.cursor.parent.children;
            let idx = sibs.indexOf(this.eng.cursor);
            let next = sibs[(idx + 1) % sibs.length];
            this.swapToSibling(next);
          }
        },
        prevVar() {
          if (this.eng.cursor.parent) {
            let sibs = this.eng.cursor.parent.children;
            let idx = sibs.indexOf(this.eng.cursor);
            let prev = sibs[(idx - 1 + sibs.length) % sibs.length];
            this.swapToSibling(prev);
          }
        },
        swapToSibling(node) {
          // Undo current
          let p = this.eng.cursor.data;
          this.eng.board[p.fy][p.fx] = p.p;
          this.eng.board[p.ty][p.tx] = p.cap;

          // Do new
          let n = node.data;
          this.eng.board[n.ty][n.tx] = n.p;
          this.eng.board[n.fy][n.fx] = null;

          this.eng.cursor = node;
          // Turn stays same
          ui.render();
          ui.updateInfo();
        },

        step(d) {
          if (d === -1) {
            this.undo();
            return;
          }
          // Step forward: check if current cursor has children
          if (this.eng.cursor.children.length > 0) {
            // Default to first child (main line of this branch)
            let next = this.eng.cursor.children[0];
            // Execute
            let n = next.data;
            this.eng.board[n.ty][n.tx] = n.p;
            this.eng.board[n.fy][n.fx] = null;
            this.eng.cursor = next;
            this.eng.turn = this.eng.turn === "r" ? "b" : "r";
            ui.render();
            ui.updateInfo();
          }
        },
        togglePlay() {
          if (this.isPlaying) this.stopPlay();
          else {
            this.isPlaying = true;
            ui.updateInfo();
            this.playTimer = setInterval(() => {
              if (this.eng.cursor.children.length > 0) this.step(1);
              else this.stopPlay();
            }, 1000);
          }
        },
        stopPlay() {
          clearInterval(this.playTimer);
          this.isPlaying = false;
          ui.updateInfo();
        },

        load() {
          let txt = document.getElementById("fenBox").value.trim();
          if (!txt) return;
          this.stopPlay();

          let fen = this.startFen;
          let mainMoveStr = "";
          let branches = [];

          if (txt.includes("[DhtmlXQ]")) {
            let f = txt.match(/_fen](.*?)\[/);
            if (f) fen = f[1];
            let m = txt.match(/_movelist](.*?)\[/);
            if (m) mainMoveStr = m[1];

            // Extract all branch tags: [DhtmlXQ_move_ParentID_MoveIdx_NewID]Moves[/...]
            const regex = /\[DhtmlXQ_move_(\d+)_(\d+)_(\d+)\](.*?)\[/g;
            let match;
            while ((match = regex.exec(txt)) !== null) {
              branches.push({
                pid: parseInt(match[1]),
                idx: parseInt(match[2]),
                id: parseInt(match[3]),
                moves: match[4],
              });
            }
          } else if (/^\d+$/.test(txt)) {
            fen =
              "rnbakabnr/9/1c5c1/p1p1p1p1p/9/9/P1P1P1P1P/1C5C1/9/RNBAKABNR w - - 0 1";
            mainMoveStr = txt;
          } else if (txt.includes("/")) {
            fen = txt;
          }

          this.eng.reset();
          this.loadFenTo(fen, this.eng);
          this.startFen = fen;
          this.isGameOver = false;
          this.gameOverStatus = "";

          // We need a map to store the 'tip' of every branch ID so we can attach new moves
          // Branch 0 is the main line.
          // Map<BranchID, MoveNode>
          let branchTips = new Map();
          branchTips.set(0, this.eng.root);

          // Function to process a string of moves starting from a specific node
          const processMoves = (node, moveStr, branchId) => {
            let curr = node;
            for (let i = 0; i < moveStr.length; i += 4) {
              let fx = parseInt(moveStr[i]);
              let fy = parseInt(moveStr[i + 1]);
              let tx = parseInt(moveStr[i + 2]);
              let ty = parseInt(moveStr[i + 3]);

              // We need to simulate the board state up to 'curr' to validate
              // But full simulation is expensive. For loading, we assume validity
              // OR we have to traverse root->curr to set board.
              // Simple approach: We trust the data for tree construction, validation is minimal
              // BUT we need the Piece info 'p' and 'cap' for navigation.

              // REBUILD BOARD STATE at 'curr'
              let tmpEng = new Engine();
              this.loadFenTo(this.startFen, tmpEng);
              // Trace path
              let path = [];
              let pNode = curr;
              while (pNode.parent) {
                path.push(pNode.data);
                pNode = pNode.parent;
              }
              path.reverse().forEach((m) => {
                tmpEng.board[m.ty][m.tx] = m.p;
                tmpEng.board[m.fy][m.fx] = null;
                tmpEng.turn = tmpEng.turn === "r" ? "b" : "r";
              });

              let p = tmpEng.getPiece(fx, fy);
              let cap = tmpEng.board[ty][tx];
              let mvStr = `${fx}${fy}${tx}${ty}`;

              let newNode = new MoveNode(
                { fx, fy, tx, ty, p, cap, mv: mvStr },
                curr
              );
              newNode.tempBranchId = branchId;
              curr.children.push(newNode);
              curr = newNode;
            }
            return curr; // Return the tip
          };

          // 1. Process Main Line (Branch 0)
          let mainTip = processMoves(this.eng.root, mainMoveStr, 0);

          // Store all nodes in Main Line into a map indexed by move count?
          // We need to access them by index.
          // Let's create a helper to find node by branchID and Index.
          // Since structure is tree, we have to crawl.

          // Optimization: During parsing, we just need to find the node to attach to.
          // The format [DhtmlXQ_move_0_8_1] means attach to the node at index 8 of branch 0.
          // Index 8 means the 8th move (so 8 steps from root).

          // Sort branches by ID to ensure parents exist? Usually ID increases.
          branches.sort((a, b) => a.id - b.id);

          const findNode = (branchId, index) => {
            // DFS to find a node that has tempBranchId == branchId at depth == index
            // Actually, the branchID property in DhtmlXQ is loose.
            // It implies "The path that was generated as ID X".

            // Let's assume standard format:
            // 0 is main.
            // If a branch says parent is 0, we walk down the "0" path 'index' times.
            // But if we branched before, the path "0" continues on the first child usually.

            let q = [{ n: this.eng.root, d: 0 }];
            while (q.length) {
              let { n, d } = q.shift();
              // Check if this node belongs to the path of branchId
              // This logic is tricky because DhtmlXQ implicit paths.
              // Simpler: If parentID=0, follow child[0] 'index' times.
              // If parentID=1, find where branch 1 started, follow child[0]...
            }
            // RE-THINK: We can just use the branchTips map if we track the "spine" of each branch.
            // When we process Main Line, every node is part of Branch 0.
            // When we process Branch 1, every node is part of Branch 1.
          };

          // Better Strategy: Assign BranchIDs to nodes during creation.
          // Main line nodes get ID 0.
          // When creating Branch 1, we find the node with ID=ParentID at Depth=Index.

          // Re-process Main Line to set IDs
          let curr = this.eng.root;
          while (curr.children.length) {
            curr.children[0].tempBranchId = 0;
            curr = curr.children[0];
          }

          // Process Branches
          branches.forEach((b) => {
            // Find parent node: Search tree for node with tempBranchId == b.pid at depth b.idx
            let parentNode = null;
            let q = [{ n: this.eng.root, d: 0 }];
            while (q.length) {
              let { n, d } = q.shift();
              if (d === b.idx && n.tempBranchId === b.pid) {
                parentNode = n;
                break;
              }
              // Optimization: Don't go deeper than needed
              if (d < b.idx) {
                n.children.forEach((c) => q.push({ n: c, d: d + 1 }));
              }
            }

            if (parentNode) {
              processMoves(parentNode, b.moves, b.id);
            }
          });

          // Reset to Start
          this.eng.cursor = this.eng.root;

          // Determine turn
          let startTurn = this.startFen.split(" ")[1] || "r";
          this.eng.turn = startTurn === "w" ? "r" : startTurn;

          this.checkGameOver();
          ui.init();
          sfx.play(500, "square");
        },

        loadFenTo(fen, engine) {
          let rows = fen.split(" ")[0].split("/");
          engine.board = Array(10)
            .fill(null)
            .map(() => Array(9).fill(null));
          rows.forEach((r, y) => {
            let x = 0;
            for (let c of r) {
              if (!isNaN(c)) x += parseInt(c);
              else {
                let color = c === c.toUpperCase() ? "r" : "b",
                  t = c.toUpperCase();
                if (t === "H") t = "N";
                if (t === "B") t = "E";
                engine.board[y][x] = color + t;
                x++;
              }
            }
          });
          engine.turn = fen.split(" ")[1] || "r";
          if (engine.turn === "w") engine.turn = "r";
        },
        checkGameOver() {
          const moves = this.eng.getLegalMoves();
          const winTxt =
            ui
              .getText(this.eng.turn === "r" ? "blackMove" : "redMove")
              .split(" ")[0] + ui.getText("win");

          if (moves.length === 0) {
            this.isGameOver = true;
            if (this.eng.inCheck(this.eng.turn)) {
              this.gameOverStatus = winTxt;
              ui.splash("绝 杀");
            } else {
              this.gameOverStatus = ui.getText("stalemate");
              ui.splash("闷 宫");
            }
          } else if (this.eng.inCheck(this.eng.turn)) ui.splash("將 軍");
          ui.updateInfo();
        },
        genNotation(tempEng, move, isReflect) {
          const { fx, fy, tx, ty, p } = move;
          if (!p) return "";
          const red = p[0] === "r",
            type = p[1];
          let name = CN_PIECES[p];
          let srcF, dstF;
          if (!isReflect) {
            srcF = red ? 9 - fx : fx + 1;
            dstF = red ? 9 - tx : tx + 1;
          } else {
            srcF = red ? fx + 1 : 9 - fx;
            dstF = red ? tx + 1 : 9 - tx;
          }
          let sameCol = [];
          if (!["A", "E", "K"].includes(type)) {
            for (let y = 0; y < 10; y++)
              if (tempEng.board[y][fx] === p) sameCol.push(y);
          }
          let otherColHasStack = false;
          if (!["A", "E", "K"].includes(type)) {
            for (let x = 0; x < 9; x++) {
              if (x === fx) continue;
              let count = 0;
              for (let y = 0; y < 10; y++)
                if (tempEng.board[y][x] === p) count++;
              if (count > 1) {
                otherColHasStack = true;
                break;
              }
            }
          }
          let prefix = "",
            useFileInsteadOfName = false;
          if (sameCol.length > 1) {
            if (red) sameCol.sort((a, b) => a - b);
            else sameCol.sort((a, b) => b - a);
            let idx = sameCol.indexOf(fy);
            if (sameCol.length === 2) prefix = idx === 0 ? "前" : "后";
            else if (sameCol.length === 3)
              prefix = idx === 0 ? "前" : idx === 1 ? "中" : "后";
            else {
              const P_MAP = ["前", "二", "三", "四", "五"];
              prefix = idx === sameCol.length - 1 ? "后" : P_MAP[idx];
            }
            if (otherColHasStack && type === "P") useFileInsteadOfName = true;
            name = useFileInsteadOfName
              ? prefix + (red ? CN_NUMS[srcF] : CN_DIGITS[srcF])
              : prefix + name;
          }
          const dy = ty - fy;
          let dir = fy === ty ? "=" : (red ? dy < 0 : dy > 0) ? "+" : "-";
          let dest = "";
          if (["R", "C", "P", "K"].includes(type) && dir !== "=") {
            let dist = Math.abs(dy);
            dest = red ? CN_NUMS[dist] : CN_DIGITS[dist];
          } else dest = red ? CN_NUMS[dstF] : CN_DIGITS[dstF];
          if (sameCol.length > 1) return name + CN_DIR[dir] + dest;
          let fChar = red ? CN_NUMS[srcF] : CN_DIGITS[srcF];
          return name + fChar + CN_DIR[dir] + dest;
        },
        export() {
          // 1. FEN
          let fen = "";
          for (let y = 0; y < 10; y++) {
            let e = 0;
            for (let x = 0; x < 9; x++) {
              let p = this.eng.board[y][x];
              if (!p) e++;
              else {
                if (e) fen += e;
                e = 0;
                let c = p[1];
                if (c === "N") c = "H";
                if (c === "E") c = "B";
                fen += p[0] === "r" ? c.toUpperCase() : c.toLowerCase();
              }
            }
            if (e) fen += e;
            if (y < 9) fen += "/";
          }
          fen += ` ${this.eng.turn} - - 0 1`;

          // 2. BINIT (XY coordinates)
          let tmp = new Engine();
          if (this.startFen) this.loadFenTo(this.startFen, tmp);
          let binitStr = "";
          for (let y = 0; y < 10; y++) {
            for (let x = 0; x < 9; x++) {
              if (tmp.board[y][x]) binitStr += `${x}${y}`;
            }
          }

          // 3. Move List & Branch Generation
          // Strategy: BFS Traversal to generate move strings
          let mainMoveStr = "";
          let branchTags = "";
          let branchIdCounter = 1;

          // Queue item: { node, branchId, isMain }
          // We assign Branch 0 to the first child of root, then first child of that, etc.
          // Any 2nd, 3rd children get new Branch IDs.

          let q = [{ n: this.eng.root, bid: 0, depth: 0 }];
          // We need to map Node -> {bid, depth} to identify parents
          let nodeMap = new Map();
          nodeMap.set(this.eng.root, { bid: 0, depth: 0 });

          // Helper to trace full strings for a branch segment
          // Because DhtmlXQ stores the *rest of the line* in the tag, not just one move.
          // So we don't strictly do BFS. We trace lines.

          let pending = [
            { startNode: this.eng.root, bid: 0, parentBid: 0, parentDepth: 0 },
          ];

          while (pending.length) {
            let task = pending.shift();
            let curr = task.startNode;
            let str = "";

            // Traverse down the "main" line of this branch (index 0 children)
            // But actually, if we are at Root, child 0 is main.
            // If we are branching off, the first move is the branch.

            // If task.startNode is Root, we iterate children[0] as main.
            // Siblings are branches.

            if (task.startNode === this.eng.root) {
              // Handle Main Line
              let ptr = this.eng.root;
              let d = 0;
              while (ptr.children.length > 0) {
                let next = ptr.children[0];
                str += next.data.mv;

                // Check siblings of next
                for (let k = 1; k < ptr.children.length; k++) {
                  // New Branch
                  pending.push({
                    startNode: ptr.children[k],
                    bid: branchIdCounter++,
                    parentBid: 0,
                    parentDepth: d, // index of 'ptr' (the move before deviation)
                  });
                }

                ptr = next;
                d++;
                // Associate ptr with branch 0 for deeper branching reference
                nodeMap.set(ptr, { bid: 0, depth: d });
              }
              mainMoveStr = str;
            } else {
              // Handle Sub Branch
              // The task.startNode IS the first move of the new branch
              let ptr = task.startNode;
              str += ptr.data.mv;
              let d = 1; // Depth relative to this branch tag start? No, absolute depth?
              // DhtmlXQ format: [move_ParentID_ParentIdx_NewID]
              // ParentIdx is the 0-based index of the move *before* the deviation.

              // Let's trace this branch until end
              while (ptr.children.length > 0) {
                let next = ptr.children[0];
                str += next.data.mv;

                // Siblings
                for (let k = 1; k < ptr.children.length; k++) {
                  // New Branch off this branch
                  pending.push({
                    startNode: ptr.children[k],
                    bid: branchIdCounter++,
                    parentBid: task.bid,
                    parentDepth: task.parentDepth + d,
                  });
                }

                ptr = next;
                d++;
              }

              branchTags += `[DhtmlXQ_move_${task.parentBid}_${task.parentDepth}_${task.bid}]${str}[/DhtmlXQ_move_${task.parentBid}_${task.parentDepth}_${task.bid}]\n`;
            }
          }

          // 4. Text Notation (Active Path Only)
          let tmpNot = new Engine();
          if (this.startFen) this.loadFenTo(this.startFen, tmpNot);
          let movesTxt = "";
          let hist = this.eng.getHistory();
          hist.forEach((h, i) => {
            let not = this.genNotation(tmpNot, h, false);
            movesTxt += i % 2 === 0 ? `${i / 2 + 1}. ${not} ` : `${not}\n`;
            tmpNot.board[h.ty][h.tx] = tmpNot.board[h.fy][h.fx];
            tmpNot.board[h.fy][h.fx] = null;
          });

          let output = `[DhtmlXQ]\n[DhtmlXQ_fen]${this.startFen}[/DhtmlXQ_fen]\n[DhtmlXQ_binit]${binitStr}[/DhtmlXQ_binit]\n[DhtmlXQ_movelist]${mainMoveStr}[/DhtmlXQ_movelist]\n${branchTags}[/DhtmlXQ]\n开始局面: ${this.startFen}\n着法:\n${movesTxt}\n使用皮卡鱼象棋在线分析: https://www.xiangqiai.com`;

          document.getElementById("fenBox").value = output;
          navigator.clipboard.writeText(output);
          alert(ui.getText("copied"));
        },
      };

      ui.init();
    </script>
  </body>
</html>
